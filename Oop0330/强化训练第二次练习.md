#### 1、2、3见代码
#### 4.创建线程的两种方式分别是什么？各有什么优缺点？
```
第一种是继承Thread类，并覆盖run()方法。
优点：编写简单；
缺点：无法继承其它父类，同时不能实现资源共享。

第二种是实现Runnable接口，并实现run()方法。
优点：可继承其它类，多线程可共享同一个Thread对象；
缺点：编程复杂，如需访问当前线程，需调用Thread.currentThread()方法
```
#### 5.请你简述sleep( )和wait( )有什么区别？
```
sleep()是就绪状态，休眠时间过完了就会准备重新执行。
wait()会释放一个锁的标志，让线程进入等待状态，等待被其他的线程唤醒，唤醒之后又重新进入就绪状态。
```
#### 6.Java中实现线程通信的三个方法及其作用？
```
wait():导致当前线程等待，直到其他线程调用notify()方法或notifyAll()方法来唤醒该线程。
notify():唤醒等待的单个线程。
notifyAll():唤醒等待的所有线程。
```
#### 7.现在有线程 T1、T2 和 T3。你如何确保 T2 线程在 T1 之后执行，并且 T3 线程在 T2 之后执行？
```
（昨天作业的代码）：
 第一种方法：Thread 类的 join 方法实现
 第二种方法：三个线程类设置休眠长度不同(T1设置为1000  T2设置为3000  T3设置为5000)

```
#### 8.Java 中新的 Lock 接口相对于同步代码块（synchronized block）有什么优势？如果让你实现一个高性能缓存，支持并发读取和单一写入，你如何保证数据完整性。
```
synchronized无法判断是否获取锁的状态,lock可以判断是否获取锁

使用synchronized的两个线程A和B 如果线程A 获得了锁,那么B一定在等待中.如果线程A阻塞了,则线程B会一直等待下去,lock不一定会等待。

synchronized的锁可重入,不可中断,而lock锁可重入，可中断

synchronized适合少量的代码同步,Lock比较适合大量的同步代码的问题 
```
#### 9.Java 中 wait 和 sleep 方法有什么区别？
```
sleep()是就绪状态，休眠时间过完了就会准备重新执行。
wait()会释放一个锁的标志，让线程进入等待状态，等待被其他的线程唤醒，唤醒之后又重新进入就绪状态。
```
#### 10.如何在 Java 中编写代码解决生产者消费者问题
```
没写出来
```
#### 11.写一段死锁代码。你在 Java 中如何解决死锁？
```
见代码中
```
#### 12.什么是原子操作？Java 中有哪些原子操作
```
原子性：一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。
```
#### 13.既然 start() 方法会调用 run() 方法，为什么我们调用 start() 方法，而不直接调用 run() 方法
```
run 被线程对象调用就是一个普通方法
start 被线程对象调用  start 会默认的去调用 run()方法
```